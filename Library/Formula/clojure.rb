require 'formula'

def readline?
  ARGV.include? '--readline'
end

class Clojure <Formula
  url 'https://github.com/downloads/clojure/clojure/clojure-1.2.0.zip'
  md5 'da0cc71378f56491d6ee70dee356831f'
  head 'git://github.com/clojure/clojure.git'
  homepage 'http://clojure.org/'

  depends_on 'rlwrap' if readline?

  def options
    [['--readline', 'Add readline support']]
  end

  def jar
    'clojure.jar'
  end

  def completions
    <<-EOS.undent
      sorted-map
      read-line
      re-pattern
      keyword?
      val
      *compile-path*
      max-key
      list*
      ns-aliases
      the-ns
      ==
      longs
      special-form-anchor
      instance?
      syntax-symbol-anchor
      format
      sequential?
      fn?
      empty
      dorun
      time
      remove-method
      gensym
      not=
      *3
      unchecked-multiply
      doseq
      bit-or
      aset-byte
      if-not
      hash-set
      add-watch
      unchecked-dec
      some
      nil?
      string?
      second
      letfn
      keys
      for
      *2
      long-array
      cond
      bit-set
      fn
      sorted?
      ns-unalias
      ns-publics
      dosync
      all-ns
      long
      with-open
      init-proxy
      add-classpath
      false?
      await1
      true?
      gen-interface
      sync
      short
      ns-unmap
      repeat
      zipmap
      distinct
      get-in
      bit-xor
      char-escape-string
      complement
      let
      get-validator
      dotimes
      print-namespace-doc
      *ns*
      defmethod
      derive
      aset-float
      lazy-cat
      commute
      defstruct
      with-in-str
      rem
      odd?
      symbol?
      *print-level*
      *allow-unresolved-vars*
      *macro-meta*
      proxy-call-with-super
      ns-interns
      re-matches
      split-with
      find-doc
      loop
      remove-watcher
      next
      import
      symbol
      vals
      print-doc
      select-keys
      re-matcher
      rand
      deref
      unchecked-inc
      *math-context*
      read
      sequence
      make-hierarchy
      +
      number?
      descendants
      into-array
      last
      unchecked-negate
      integer?
      alter
      prn
      with-meta
      with-out-str
      floats
      *
      *compile-files*
      when-not
      butlast
      -
      reversible?
      rseq
      send-off
      seq?
      refer-clojure
      identical?
      ..
      print
      vary-meta
      *command-line-args*
      bit-flip
      zero?
      bit-and
      unquote-splicing
      future
      re-groups
      *warn-on-reflection*
      newline
      replicate
      distinct?
      remove-ns
      ratio?
      xml-seq
      vec
      concat
      update-in
      vector
      conj
      bases
      /
      unchecked-add
      ref-set
      assoc
      seque
      aset-char
      boolean
      read-string
      neg?
      float-array
      doubles
      isa?
      future-call
      doto
      remove-watch
      print-str
      *e
      rsubseq
      *flush-on-newline*
      *out*
      vector?
      split-at
      ns-refers
      create-struct
      proxy-super
      int-array
      float
      assert
      map
      counted?
      memfn
      double-array
      accessor
      *print-length*
      class?
      rand-int
      *1
      aset-short
      prn-str
      iterate
      add-watcher
      when-first
      slurp
      mapcat
      assoc-in
      special-symbol?
      ref
      find-var
      inc
      definline
      unchecked-subtract
      ns-name
      defn-
      *file*
      re-find
      bit-not
      construct-proxy
      destructure
      seq
      intern
      pvalues
      to-array-2d
      sorted-map-by
      filter
      var?
      alter-meta!
      comment
      key
      class
      re-seq
      ns
      empty?
      test
      print-dup
      create-ns
      name
      list?
      aset
      nnext
      doall
      macroexpand-1
      not-any?
      resultset-seq
      into
      with-precision
      *use-context-classloader*
      ffirst
      bit-clear
      proxy-name
      load-reader
      or
      hash
      print-ctor
      associative?
      float?
      drop-last
      replace
      decimal?
      defn
      parents
      map?
      prefers
      condp
      quot
      file-seq
      send
      with-local-vars
      reverse
      count
      get-proxy-class
      set
      when-let
      comp
      nth
      byte
      *err*
      constantly
      load
      namespace
      pr-str
      <
      rationalize
      sort-by
      cycle
      peek
      reduce
      interleave
      amap
      ->
      cons
      macroexpand
      var-set
      str
      aset-boolean
      ns-imports
      while
      first
      bean
      =
      memoize
      var-get
      range
      tree-seq
      defmacro
      set-validator!
      aset-double
      enumeration-seq
      prefer-method
      ensure
      find-ns
      not-every?
      struct-map
      >
      max
      proxy-mappings
      identity
      ints
      fnext
      min-key
      reset-meta!
      subs
      compile
      agent-errors
      clear-agent-errors
      printf
      ns-resolve
      method-sig
      >=
      shutdown-agents
      reset!
      even?
      require
      bit-shift-left
      methods
      compare
      cast
      supers
      pcalls
      load-string
      get
      <=
      await
      resolve
      print-method
      loaded-libs
      force
      partial
      pmap
      if-let
      comparator
      pos?
      char
      take-while
      and
      refer
      underive
      in-ns
      iterator-seq
      declare
      ancestors
      locking
      partition
      contains?
      update-proxy
      interpose
      aset-int
      ifn?
      load-file
      delay
      apply
      swap!
      defmulti
      proxy
      subvec
      rest
      keyword
      ns-map
      unquote
      int
      release-pending-sends
      mod
      bigdec
      nfirst
      nthnext
      *agent*
      aset-long
      struct
      array-map
      bigint
      dec
      println
      aget
      pr
      drop
      *print-dup*
      gen-class
      eval
      unchecked-remainder
      aclone
      char-name-string
      pop
      primitives-classnames
      atom
      defonce
      bit-shift-right
      delay?
      num
      disj
      io!
      *print-readably*
      rational?
      merge-with
      take-nth
      *print-meta*
      double
      lazy-seq
      *in*
      line-seq
      take
      when
      areduce
      set?
      make-array
      alias
      use
      if
      alength
      *source-path*
      to-array
      hash-map
      bit-and-not
      compare-and-set!
      type
      repeatedly
      trampoline
      remove
      find
      coll?
      drop-while
      not-empty
      print-special-doc
      println-str
      list
      every?
      flush
      sort
      dissoc
      not
      binding
      doc
      agent
      sorted-set
      alter-var-root
      merge
      subseq
      min
      print-simple
      bit-test
      await-for
      meta
      unchecked-divide
      rename-keys
      union
      select
      project
      join
      intersection
      map-invert
      difference
      rename
      index
      content-handler
      *stack*
      attrs
      element
      tag
      startparse-sax
      *current*
      content
      *state*
      parse
      emit-element
      *sb*
      emit
      lefts
      down
      insert-left
      up
      next
      path
      children
      vector-zip
      append-child
      zipper
      branch?
      end?
      leftmost
      edit
      replace
      insert-right
      root
      insert-child
      prev
      seq-zip
      xml-zip
      make-node
      rights
      node
      right
      left
      remove
      rightmost
    EOS
  end

  def script
    if readline?
      break_chars = %q{\(\){}[],^%$#@\"\";:''|\\\\}
      <<-EOS.undent
        #!/bin/sh
        # Runs clojure.
        # With no arguments, runs Clojure's REPL

        cp=$(brew --prefix clojure)/libexec/#{jar}

        if [ $# -eq 0 ]; then
          rlwrap --remember -c -b '#{break_chars}' -f #{share}/clojure/clj_completions java -cp $cp clojure.main
        else
          exec java -cp $cp clojure.main $*
        fi
      EOS
    else
      <<-EOS.undent
        #!/bin/sh
        # Runs clojure.
        # With no arguments, runs Clojure's REPL.

        cp=$(brew --prefix clojure)/libexec/#{jar}

        if [ $# -eq 0 ]; then
          exec java -cp $cp clojure.main
        else
          exec java -cp $cp clojure.main $*
        fi
      EOS
    end
  end

  def install
    system "ant" if ARGV.build_head?
    libexec.install jar
    (bin+'clj').write script
    (share+'clojure/clj_completions').write completions
  end
end
